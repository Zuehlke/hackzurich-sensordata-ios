//
//  MicophoneSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//
import AVFoundation
import UIKit

/**
 The purpose of the `MicrophoneSensor` class is to provide the data that is generated by the microphone of the device. 
 
 The `MicrophoneSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class MicrophoneSensor: AbstractSensor, DeviceSensor, AVAudioRecorderDelegate {
    
    
    fileprivate var recordingSession = AVAudioSession.sharedInstance()
    fileprivate var audioRecorder : AVAudioRecorder?
    fileprivate var intervalTimer: Timer?
    
    /// A Bool that indicates that the microphone is available on the device which is the case on real hardware
    var isAvailable : Bool{
        
        get{
            if UIDevice.current.isSimulator{
                return false
            }
            return true
        }
    }
    
    /// The type of class is Microphone
    var type : SensorType {
        get{
            return .Microphone
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
    init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .Microphone)
        
        try! recordingSession.setCategory(AVAudioSessionCategoryRecord)
    }
    
    /**
     Method to start the reporting of sensor data. The data is read with a NSTimer that kicks of a reading in a defined interval
     */
    func startReporting(){
        
        guard isAvailable else {
            print("Micophone not available")
            return
        }

        clearPermission { (permissionGranted: Bool) in
            super._isReporting = true
            DispatchQueue.global(qos: .background).async {
                self.recordAudio()
            }
        }
    }
    
    //Method that configures the recording and starts the reading timer
    fileprivate func recordAudio(){
    
        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000.0,
            AVNumberOfChannelsKey: 1 as NSNumber,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ] as [String : Any]
    
        try! audioRecorder = AVAudioRecorder(url: URL(string: "dev/null")!, settings: settings)
        audioRecorder?.delegate = self
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()
        
        try! recordingSession.setActive(true)
        
        audioRecorder?.record()
        audioRecorder?.updateMeters()
        
        DispatchQueue.global(qos: .background).async {
            self.intervalTimer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(self.intervalTimerFired), userInfo: nil, repeats: true)
            RunLoop.current.add(self.intervalTimer!, forMode: RunLoopMode.defaultRunLoopMode)
            RunLoop.current.run()
        }
    }

    /**
     Method that gets called if the record timer fired. The normalized power values are recorded - nothing more
     */
    func intervalTimerFired(){
        
        guard let audioRecorder = self.audioRecorder else {return}
        audioRecorder.updateMeters()
        let averagePower = audioRecorder.averagePower(forChannel: 0)
        let peakPower = audioRecorder.peakPower(forChannel: 0)
        
        persistData(averagePower,peakPower: peakPower)
    }
    
    
    fileprivate func clearPermission(_ successHandler: @escaping (Bool) -> ()){
    
        do {
            try recordingSession.setCategory(AVAudioSessionCategoryPlayAndRecord)
            try recordingSession.setActive(true)
            recordingSession.requestRecordPermission({ (allowed:Bool) in
                print("recording of microphone is allowed: \(allowed)")
                successHandler(allowed)
            })
        
        } catch {
            print("error getting microphone permission")
            successHandler(false)
        }
    }
    
    ///method that writes the data from the sensor into a dictionary structur for later JSON generation
    fileprivate func persistData(_ averagePower: Float, peakPower: Float){
        
        var params = [String:AnyObject]()
        params["type"] = "Microphone" as AnyObject?
        params["date"] =   dateFormatter.string(from: Date()) as AnyObject?
        params["averagePower"] = averagePower as AnyObject?
        params["peakPower"] = peakPower as AnyObject?
        
        fileWriter?.addLine(params)
    }
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
        
        intervalTimer?.invalidate()
        audioRecorder?.stop()
        try! recordingSession.setActive(false)
        _isReporting = false
    }
}
