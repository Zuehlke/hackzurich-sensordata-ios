//
//  MicophoneSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//
import AVFoundation
import UIKit

/**
 The purpose of the `MicrophoneSensor` class is to provide the data that is generated by the microphone of the device. 
 
 The `MicrophoneSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class MicrophoneSensor: AbstractSensor, DeviceSensor, AVAudioRecorderDelegate {
    
    
    private var recordingSession = AVAudioSession.sharedInstance()
    private var audioRecorder : AVAudioRecorder?
    private var intervalTimer: NSTimer?
    
    /// A Bool that indicates that the microphone is available on the device which is the case on real hardware
    var isAvailable : Bool{
        
        get{
            if UIDevice.currentDevice().isSimulator{
                return false
            }
            return true
        }
    }
    
    /// The type of class is Microphone
    var type : SensorType {
        get{
            return .Microphone
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
    init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .Microphone)
        
        try! recordingSession.setCategory(AVAudioSessionCategoryRecord)
    }
    
    /**
     Method to start the reporting of sensor data. The data is read with a NSTimer that kicks of a reading in a defined interval
     */
    func startReporting(){
        
        guard isAvailable else {
            print("Micophone not available")
            return
        }

        clearPermission { (permissionGranted: Bool) in
            super._isReporting = true
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), {
                self.recordAudio()
            })
        }
    }
    
    //Method that configures the recording and starts the reading timer
    private func recordAudio(){
    
        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000.0,
            AVNumberOfChannelsKey: 1 as NSNumber,
            AVEncoderAudioQualityKey: AVAudioQuality.High.rawValue
        ]
    
        try! audioRecorder = AVAudioRecorder(URL: NSURL(string: "dev/null")!, settings: settings)
        audioRecorder?.delegate = self
        audioRecorder?.meteringEnabled = true
        audioRecorder?.prepareToRecord()
        
        try! recordingSession.setActive(true)
        
        audioRecorder?.record()
        audioRecorder?.updateMeters()
        
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), {
            self.intervalTimer = NSTimer.scheduledTimerWithTimeInterval(0.1, target: self, selector: #selector(self.intervalTimerFired), userInfo: nil, repeats: true)
            NSRunLoop.currentRunLoop().addTimer(self.intervalTimer!, forMode: NSDefaultRunLoopMode)
            NSRunLoop.currentRunLoop().run()
        });
    }

    /**
     Method that gets called if the record timer fired. The normalized power values are recorded - nothing more
     */
    func intervalTimerFired(){
        
        guard let audioRecorder = self.audioRecorder else {return}
        audioRecorder.updateMeters()
        let averagePower = audioRecorder.averagePowerForChannel(0)
        let peakPower = audioRecorder.peakPowerForChannel(0)
        
        persistData(averagePower,peakPower: peakPower)
    }
    
    
    private func clearPermission(successHandler: Bool -> ()){
    
        do {
            try recordingSession.setCategory(AVAudioSessionCategoryPlayAndRecord)
            try recordingSession.setActive(true)
            recordingSession.requestRecordPermission({ (allowed:Bool) in
                print("recording of microphone is allowed: \(allowed)")
                successHandler(allowed)
            })
        
        } catch {
            print("error getting microphone permission")
            successHandler(false)
        }
    }
    
    ///method that writes the data from the sensor into a dictionary structur for later JSON generation
    private func persistData(averagePower: Float, peakPower: Float){
        
        var params = [String:AnyObject]()
        params["type"] = "Microphone"
        params["date"] = dateFormatter.stringFromDate(NSDate())
        params["averagePower"] = averagePower
        params["peakPower"] = peakPower
        
        fileWriter?.addLine(params)
    }
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
        
        intervalTimer?.invalidate()
        audioRecorder?.stop()
        try! recordingSession.setActive(false)
        _isReporting = false
    }
}
