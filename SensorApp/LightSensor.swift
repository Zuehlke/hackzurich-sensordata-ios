//
//  LightSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//
import AVFoundation
import UIKit
/**
 The purpose of the `LightSensor` class is to provide the data that is generated by the camera of the device.
 The `LightSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class LightSensor: AbstractSensor, DeviceSensor {
    
    private var device = UIDevice.currentDevice()
    private var captureSession : AVCaptureSession?
    private var captureDevice : AVCaptureDevice?
    private let stillImageOutput = AVCaptureStillImageOutput()
    private var intervalTimer: NSTimer?
    
    /// A Bool that indicates that the camera on the back is available for video recording
    var isAvailable : Bool{
        
        get{
            if UIDevice.currentDevice().isSimulator{
                return false
            }
            
            for device in AVCaptureDevice.devices() {
                if (device.hasMediaType(AVMediaTypeVideo)) {
                    if(device.position == .Back) {
                        return true
                    }
                }
            }
            return false
        }
    }
    
    /// The type of class is Light. This is measured by the camera
    var type : SensorType {
        get{
            return .Light
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
    init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .Light)
        
       
    }
    
    /**
     Method to start the reporting of sensor data. The data is read with a NSTimer that kicks of a reading in a defined interval
     */
    func startReporting(){
        
        guard isAvailable else {
            print("LightSensor not available")
            return
        }
        _isReporting = true
        
        captureSession = AVCaptureSession()
        captureSession?.sessionPreset = AVCaptureSessionPresetLow
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), {
            
            for device in AVCaptureDevice.devices() {
                if (device.hasMediaType(AVMediaTypeVideo)) {
                    if(device.position == .Back) {
                        self.captureDevice = device as? AVCaptureDevice
                        if self.captureDevice != nil {
                            self.beginSession()
                            break
                        }
                    }
                }
            }
         });
    }
    
    //lock the camera for constant results
    private func updateDeviceSettings(focusValue : Float, isoValue : Float) {
       
        if let device = captureDevice {
            
            try! device.lockForConfiguration()

            device.setFocusModeLockedWithLensPosition(focusValue, completionHandler: { (time) -> Void in
                //
            })
            
            // Adjust the iso to clamp between minIso and maxIso based on the active format
            let minISO = device.activeFormat.minISO
            let maxISO = device.activeFormat.maxISO
            let clampedISO = isoValue * (maxISO - minISO) + minISO
            
            device.setExposureModeCustomWithDuration(AVCaptureExposureDurationCurrent, ISO: clampedISO, completionHandler: { (time) -> Void in
                //
            })
            device.unlockForConfiguration()
        }
    }
    
    private func configureDevice() {
        if let device = captureDevice {
            try! device.lockForConfiguration()
            device.focusMode = .Locked
            device.unlockForConfiguration()
        }
    }
    
    private func beginSession() {
        
        configureDevice()

        try! captureSession?.addInput(AVCaptureDeviceInput(device: captureDevice))
    
        stillImageOutput.outputSettings = [AVVideoCodecKey:AVVideoCodecJPEG]
        if ((captureSession?.canAddOutput(stillImageOutput)) != nil) {
            captureSession?.addOutput(stillImageOutput)
        }
       
        captureSession?.startRunning()

        intervalTimer = NSTimer.scheduledTimerWithTimeInterval(5.0, target: self, selector: #selector(self.intervalTimerFired), userInfo: nil, repeats: true)
        NSRunLoop.currentRunLoop().addTimer(self.intervalTimer!, forMode: NSDefaultRunLoopMode)
        NSRunLoop.currentRunLoop().run()
    }

    
    /**
     Method that gets called if the record timer fired. An image from the video stream is taken and the average brightness of all pixels is computed
     */
    func intervalTimerFired(){
        
        if let videoConnection = stillImageOutput.connectionWithMediaType(AVMediaTypeVideo) {

            self.stillImageOutput.captureStillImageAsynchronouslyFromConnection(videoConnection) {
                (imageDataSampleBuffer, error) -> Void in
                
                guard imageDataSampleBuffer != nil else {return}
                
                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), {
                let imageData = AVCaptureStillImageOutput.jpegStillImageNSDataRepresentation(imageDataSampleBuffer)
                let image = UIImage(data: imageData)
                
                let cfData = CGDataProviderCopyData(CGImageGetDataProvider(image?.CGImage))
                let pixels = CFDataGetBytePtr(cfData)
                
                let length = CFDataGetLength(cfData)
                var luminances = [Float]()
                
                for index in 0...length{
                    let r = Float(pixels[index])/255
                    let g = Float(pixels[index+1])/255
                    let b = Float(pixels[index+2])/255
            
                    let brightnes = (r + g + b) / 3
                    luminances.append(brightnes)
                }
                
                let averageBrightness = luminances.reduce(0, combine: +) / Float(luminances.count)

                    self.persistData(averageBrightness)
                })
            }
        }
    }
    
    private func persistData(brightnes: Float){
        
        var params = [String:AnyObject]()
        params["type"] = "Light"
        params["date"] = dateFormatter.stringFromDate(NSDate())
        params["brightnes"] = brightnes
        
        fileWriter?.addLine(params)
    }
    
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
        intervalTimer?.invalidate()
        captureSession?.stopRunning()
        captureSession = nil

        _isReporting = false
    }

}
