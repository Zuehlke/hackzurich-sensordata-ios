//
//  LightSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//
import AVFoundation
import UIKit
/**
 The purpose of the `LightSensor` class is to provide the data that is generated by the camera of the device.
 The `LightSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class LightSensor: AbstractSensor, DeviceSensor {
    
    fileprivate var device = UIDevice.current
    fileprivate var captureSession : AVCaptureSession?
    fileprivate var captureDevice : AVCaptureDevice?
    fileprivate let stillImageOutput = AVCaptureStillImageOutput()
    fileprivate var intervalTimer: Timer?
    
    /// A Bool that indicates that the camera on the back is available for video recording
    var isAvailable : Bool{
        
        get{
            if UIDevice.current.isSimulator{
                return false
            }
            
            for device in AVCaptureDevice.devices() {
                if ((device as AnyObject).hasMediaType(AVMediaTypeVideo)) {
                    if((device as AnyObject).position == .back) {
                        return true
                    }
                }
            }
            return false
        }
    }
    
    /// The type of class is Light. This is measured by the camera
    var type : SensorType {
        get{
            return .Light
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
    init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .Light)
        
       
    }
    
    /**
     Method to start the reporting of sensor data. The data is read with a NSTimer that kicks of a reading in a defined interval
     */
    func startReporting(){
        
        guard isAvailable else {
            print("LightSensor not available")
            return
        }
        _isReporting = true
        
        captureSession = AVCaptureSession()
        captureSession?.sessionPreset = AVCaptureSessionPresetLow
        
        DispatchQueue.global(qos: .background).async {
            
            for device in AVCaptureDevice.devices() {
                if ((device as AnyObject).hasMediaType(AVMediaTypeVideo)) {
                    if((device as AnyObject).position == .back) {
                        self.captureDevice = device as? AVCaptureDevice
                        if self.captureDevice != nil {
                            self.beginSession()
                            break
                        }
                    }
                }
            }
         }
    }
    
    //lock the camera for constant results
    fileprivate func updateDeviceSettings(_ focusValue : Float, isoValue : Float) {
       
        if let device = captureDevice {
            
            try! device.lockForConfiguration()

            device.setFocusModeLockedWithLensPosition(focusValue, completionHandler: { (time) -> Void in
                //
            })
            
            // Adjust the iso to clamp between minIso and maxIso based on the active format
            let minISO = device.activeFormat.minISO
            let maxISO = device.activeFormat.maxISO
            let clampedISO = isoValue * (maxISO - minISO) + minISO
            
            device.setExposureModeCustomWithDuration(AVCaptureExposureDurationCurrent, iso: clampedISO, completionHandler: { (time) -> Void in
                //
            })
            device.unlockForConfiguration()
        }
    }
    
    fileprivate func configureDevice() {
        if let device = captureDevice {
            try! device.lockForConfiguration()
            device.focusMode = .locked
            device.unlockForConfiguration()
        }
    }
    
    fileprivate func beginSession() {
        
        configureDevice()

        try! captureSession?.addInput(AVCaptureDeviceInput(device: captureDevice))
    
        stillImageOutput.outputSettings = [AVVideoCodecKey:AVVideoCodecJPEG]
        if ((captureSession?.canAddOutput(stillImageOutput)) != nil) {
            captureSession?.addOutput(stillImageOutput)
        }
       
        captureSession?.startRunning()

        intervalTimer = Timer.scheduledTimer(timeInterval: 5.0, target: self, selector: #selector(self.intervalTimerFired), userInfo: nil, repeats: true)
        RunLoop.current.add(self.intervalTimer!, forMode: RunLoopMode.defaultRunLoopMode)
        RunLoop.current.run()
    }

    
    /**
     Method that gets called if the record timer fired. An image from the video stream is taken and the average brightness of all pixels is computed
     */
    func intervalTimerFired(){
        
        if let videoConnection = stillImageOutput.connection(withMediaType: AVMediaTypeVideo) {

            self.stillImageOutput.captureStillImageAsynchronously(from: videoConnection) {
                (imageDataSampleBuffer, error) -> Void in
                
                guard imageDataSampleBuffer != nil else {return}
                
                DispatchQueue.global(qos: .background).async {
                    let imageData = AVCaptureStillImageOutput.jpegStillImageNSDataRepresentation(imageDataSampleBuffer)
                    let image = UIImage(data: imageData!)
                    
                    let cfData = image?.cgImage?.dataProvider?.data
                    let pixels = CFDataGetBytePtr(cfData)
                    
                    let length = CFDataGetLength(cfData)
                    var luminances = [Float]()
                    
                    for index in 0...length{
                        let r = Float((pixels?[index])!)/255
                        let g = Float((pixels?[index+1])!)/255
                        let b = Float((pixels?[index+2])!)/255
                
                        let brightnes = (r + g + b) / 3
                        luminances.append(brightnes)
                    }
                    
                    let averageBrightness = luminances.reduce(0, +) / Float(luminances.count)

                        self.persistData(averageBrightness)
                }
            }
        }
    }
    
    fileprivate func persistData(_ brightnes: Float){
        
        var params = [String:AnyObject]()
        params["type"] = "Light" as AnyObject?
        params["date"] = dateFormatter.string(from: Date()) as AnyObject?
        params["brightnes"] = brightnes as AnyObject?
        
        fileWriter?.addLine(params)
    }
    
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
        intervalTimer?.invalidate()
        captureSession?.stopRunning()
        captureSession = nil

        _isReporting = false
    }

}
