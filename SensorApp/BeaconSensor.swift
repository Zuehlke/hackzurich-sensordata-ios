//
//  BeaconSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//

import CoreLocation
import UIKit

/**
 The purpose of the `BeaconSensor` class is to provide the data that is generated by read iBeacons
 The `BeaconSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class BeaconSensor: AbstractSensor, DeviceSensor, CLLocationManagerDelegate {
    
    fileprivate var locationManager = CLLocationManager()

    //beaconUUID must be specified that should be handled
    fileprivate let beaconRegion = CLBeaconRegion(proximityUUID:  UUID(uuidString:"f7826da6-4fa2-4e98-8024-bc5b71e0893e")!, identifier: "ranged region")
    
    /// A Bool that indicates that beacon ranging is available on the device
    var isAvailable : Bool{
        
        get{
            if UIDevice.current.isSimulator{
                return false
            }
            if !CLLocationManager.isRangingAvailable(){
                return false
            }
            return true
        }
    }
    
    /// The type of class is Beacon
    var type : SensorType {
        get{
            return .Beacon
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
     init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .Beacon)
    }
    
    
    /**
     Method to start the reporting of sensor data. The data is read periodically if a device was found
     */
    func startReporting(){
        
        guard isAvailable else {
            print("BeaconSensor not available")
            return
        }
        _isReporting = true
        
        locationManager.requestAlwaysAuthorization()
        locationManager.delegate = self
        locationManager.startRangingBeacons(in: beaconRegion)
    }
    
    /// beacons are found by the `CLLocationManager`
    func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion){
    
        DispatchQueue.global(qos: .background).async {
            self.persistData(beacons)
        }
    }
    
    ///method that writes the data from the sensor into a dictionary structur for later JSON generation
    fileprivate func persistData(_ beacons: [CLBeacon]){
        
        guard beacons.count > 0 else {return}
        
        var params = [String:AnyObject]()
        params["type"] = "Beacon" as AnyObject?
        params["date"] = dateFormatter.string(from: Date()) as AnyObject?
        
        var foundBeacons = [[String:AnyObject]]()
        for beacon in beacons{
            var beaconParams = [String:AnyObject]()
            beaconParams["id"] = beacon.proximityUUID.uuidString as AnyObject?
            beaconParams["major"] = beacon.major
            beaconParams["minor"] = beacon.minor
            beaconParams["rssi"] = beacon.rssi as AnyObject?
            beaconParams["accuracy"] = beacon.accuracy as AnyObject?
            foundBeacons.append(beaconParams)
        }
        params["beacons"] = foundBeacons as AnyObject?
        
        fileWriter?.addLine(params)
    }
    
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
        locationManager.stopRangingBeacons(in: beaconRegion)
        _isReporting = false
    }
    
}
