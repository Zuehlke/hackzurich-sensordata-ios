//
//  BatteryLevelSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//
import UIKit
/**
 The purpose of the `BatteryLevelSensor` class is to provide the data that is generated by the batterymonitor of the device. The results are used to monitor the energy of the iPhones in the lifts
 
 The `BatteryLevelSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class BatteryLevelSensor: AbstractSensor, DeviceSensor {

    fileprivate var device = UIDevice.current
    
    /// A Bool that indicates that the batterymonitor is available on the device which is the case on real hardware
    var isAvailable : Bool{
        
        get{
            if UIDevice.current.isSimulator{
                return false
            }
            return true
        }
    }
    
    /// The type of class is BatteryLevel
    var type : SensorType {
        get{
            return .BatteryLevel
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
    init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .BatteryLevel)
    }
    
    /**
     Method to start the reporting of sensor data. The data is read with a NSNotification that gets fired by the system if there is a certain change
     */
    func startReporting(){
        
        guard isAvailable else {
            print("BatteryLevelSensor not available")
            return
        }
        _isReporting = true
        device.isBatteryMonitoringEnabled = true
        NotificationCenter.default.addObserver(self, selector: #selector(self.batteryLevelChanged(_:)), name: NSNotification.Name.UIDeviceBatteryLevelDidChange, object: nil)
    }
    
    /**
     Method that gets called if the battery level has changed
     */
    func batteryLevelChanged(_ notification: Notification){

        DispatchQueue.global(qos: .background).async {
            self.persistData(self.device)
        }
    }
    
    ///method that writes the data from the sensor into a dictionary structur for later JSON generation
    fileprivate func persistData(_ device: UIDevice){
        
        var params = [String:AnyObject]()
        params["type"] = "Battery" as AnyObject?
        params["date"] = dateFormatter.string(from: Date()) as AnyObject?
        params["batteryLevel"] = device.batteryLevel as AnyObject?
        params["batteryState"] = convertBatteryStateToString(device.batteryState) as AnyObject?
        
        fileWriter?.addLine(params)
    }
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
       device.isBatteryMonitoringEnabled = false
        _isReporting = false
    }
    
    
    fileprivate func convertBatteryStateToString(_ state: UIDeviceBatteryState) -> String{
        
        switch state {
        case .unknown:
            return "Unknown"
        case .unplugged:
            return "Unplugged"
        case .charging:
            return "Charging" // plugged in, less than 100%
        case .full:
            return "Full"
        }
    }
    
}
