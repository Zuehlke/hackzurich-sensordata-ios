//
//  BatteryLevelSensor.swift
//  SensorApp
//
//  Copyright © 2016 Zühlke Engineering AG. All rights reserved.
//
import UIKit
/**
 The purpose of the `BatteryLevelSensor` class is to provide the data that is generated by the batterymonitor of the device. The results are used to monitor the energy of the iPhones in the lifts
 
 The `BatteryLevelSensor` class is a subclass of the `AbstractSensor`, and it conforms to the `DeviceSensor` protocol.
 */
class BatteryLevelSensor: AbstractSensor, DeviceSensor {

    private var device = UIDevice.currentDevice()
    
    /// A Bool that indicates that the batterymonitor is available on the device which is the case on real hardware
    var isAvailable : Bool{
        
        get{
            if UIDevice.currentDevice().isSimulator{
                return false
            }
            return true
        }
    }
    
    /// The type of class is BatteryLevel
    var type : SensorType {
        get{
            return .BatteryLevel
        }
    }
    
    /**
     Public initializer that takes`FileWriterService` as an argument.
     `FileWriterService` is used to save the measured results.
     */
    init(fileWriterService: FileWriterService) {
        super.init(fileWriterService: fileWriterService, deviceType: .BatteryLevel)
    }
    
    /**
     Method to start the reporting of sensor data. The data is read with a NSNotification that gets fired by the system if there is a certain change
     */
    func startReporting(){
        
        guard isAvailable else {
            print("BatteryLevelSensor not available")
            return
        }
        _isReporting = true
        device.batteryMonitoringEnabled = true
        NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(self.batteryLevelChanged(_:)), name: UIDeviceBatteryLevelDidChangeNotification, object: nil)
    }
    
    /**
     Method that gets called if the battery level has changed
     */
    func batteryLevelChanged(notification: NSNotification){
    
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), {
            self.persistData(self.device)
        })
    }
    
    ///method that writes the data from the sensor into a dictionary structur for later JSON generation
    private func persistData(device: UIDevice){
        
        var params = [String:AnyObject]()
        params["type"] = "Battery"
        params["date"] = dateFormatter.stringFromDate(NSDate())
        params["batteryLevel"] = device.batteryLevel
        params["batteryState"] = convertBatteryStateToString(device.batteryState)
        
        fileWriter?.addLine(params)
    }
    
    ///method that stops sensor reading and generation of data
    func stopReporting(){
       device.batteryMonitoringEnabled = false
        _isReporting = false
    }
    
    
    private func convertBatteryStateToString(state: UIDeviceBatteryState) -> String{
        
        switch state {
        case .Unknown:
            return "Unknown"
        case .Unplugged:
            return "Unplugged"
        case .Charging:
            return "Charging" // plugged in, less than 100%
        case .Full:
            return "Full"
        }
    }
    
}
