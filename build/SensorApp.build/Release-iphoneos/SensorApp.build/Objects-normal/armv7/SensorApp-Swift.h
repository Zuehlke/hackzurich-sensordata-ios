// Generated by Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.31)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import UIKit;
@import CoreBluetooth;
@import CoreLocation;
@import AVFoundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSDateFormatter;
@class NSUserDefaults;


/// The purpose of the AbstractSensor class is to provide variables and methods to DeviceSensor classes in respect to the DRY principle
SWIFT_CLASS("_TtC9SensorApp14AbstractSensor")
@interface AbstractSensor : NSObject

/// A dateformatter to write the date of the reading to cache as a formatted string
@property (nonatomic, readonly, strong) NSDateFormatter * _Nonnull dateFormatter;

/// A instance of NSUserDefaults to persist settings of the app
@property (nonatomic, readonly, strong) NSUserDefaults * _Nonnull defaults;
@property (nonatomic) BOOL _isReporting;

/// Bool that indicates if DeviceSensor has been activated
@property (nonatomic) BOOL isActive;

/// Bool that indicates if DeviceSensor reading has been activated
@property (nonatomic, readonly) BOOL isReporting;
@end



/// The purpose of the AccelerometerSensor class is to provide the data that is generated by the accelerometer of the device. For details of this sensor see https://en.wikipedia.org/wiki/Accelerometer
///
/// The <code>AccelerometerSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp19AccelerometerSensor")
@interface AccelerometerSensor : AbstractSensor

/// A Bool that indicates that the accelerometer is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with the interval specified by accelerometerUpdateInterval
- (void)startReporting;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end

@class UIWindow;
@class UIApplication;


/// The app delegate. All stubs removed as they are not needed.
SWIFT_CLASS("_TtC9SensorApp11AppDelegate")
@interface AppDelegate : UIResponder <UIApplicationDelegate>

/// The UIWindow of the app
@property (nonatomic, strong) UIWindow * _Nullable window;

/// When the application lauches all sensors are setup and the data transfer is initialized
- (BOOL)application:(UIApplication * _Nonnull)application didFinishLaunchingWithOptions:(NSDictionary * _Nullable)launchOptions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The purpose of the BarometerSensor class is to provide the data that is generated by the barometer of the device. For details of this sensor see https://en.wikipedia.org/wiki/Barometer
///
/// The <code>BarometerSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp15BarometerSensor")
@interface BarometerSensor : AbstractSensor

/// A Bool that indicates that the barometer is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read every few seconds
- (void)startReporting;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end

@class NSNotification;


/// The purpose of the BatteryLevelSensor class is to provide the data that is generated by the batterymonitor of the device. The results are used to monitor the energy of the iPhones in the lifts
///
/// The <code>BatteryLevelSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp18BatteryLevelSensor")
@interface BatteryLevelSensor : AbstractSensor

/// A Bool that indicates that the batterymonitor is available on the device which is the case on real hardware
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with a NSNotification that gets fired by the system if there is a certain change
- (void)startReporting;

/// Method that gets called if the battery level has changed
- (void)batteryLevelChanged:(NSNotification * _Nonnull)notification;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end

@class CBPeripheralManager;
@class NSError;


/// The purpose of the BeaconSender class is to use the iPhone as an iBeacon The BeaconSender class conforms to the DeviceSender protocol.
SWIFT_CLASS("_TtC9SensorApp12BeaconSender")
@interface BeaconSender : NSObject <CBPeripheralManagerDelegate>

/// A Bool that indicates that beacon ranging is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Create a random Major number. And keep it during installation
@property (nonatomic, readonly) NSInteger beaconMajor;

/// Create a random Minor number. And keep it during installation
@property (nonatomic, readonly) NSInteger beaconMinor;

/// Method to start sending
- (void)startSending;

/// Method to stop sending
- (void)stopSending;

/// CBPeripheralManagerDelegate method: start and stop advertising based on state
- (void)peripheralManagerDidUpdateState:(CBPeripheralManager * _Nonnull)peripheral;

/// CBPeripheralManagerDelegate method: printing feedback of advertising
- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager * _Nonnull)peripheral error:(NSError * _Nullable)error;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class CLLocationManager;
@class CLBeacon;
@class CLBeaconRegion;


/// The purpose of the BeaconSensor class is to provide the data that is generated by read iBeacons The BeaconSensor class is a subclass of the AbstractSensor, and it conforms to the DeviceSensor protocol.
SWIFT_CLASS("_TtC9SensorApp12BeaconSensor")
@interface BeaconSensor : AbstractSensor <CLLocationManagerDelegate>

/// A Bool that indicates that beacon ranging is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read periodically if a device was found
- (void)startReporting;

/// beacons are found by the CLLocationManager
- (void)locationManager:(CLLocationManager * _Nonnull)manager didRangeBeacons:(NSArray<CLBeacon *> * _Nonnull)beacons inRegion:(CLBeaconRegion * _Nonnull)region;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end



/// The purpose of the DeviceMotionSensor class is to provide the data that is generated by the devicemotion sensor of the device. For details of this sensor see http://nshipster.com/cmdevicemotion/
///
/// The <code>DeviceMotionSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp18DeviceMotionSensor")
@interface DeviceMotionSensor : AbstractSensor

/// A Bool that indicates that the motion sensor is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with the interval specified by accelerometerUpdateInterval
- (void)startReporting;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end

@class NSDate;
@class UILabel;
@class NSCoder;


/// This class is the view model for the error cell. It displays the error sent via NSNotificationCenter.
SWIFT_CLASS("_TtC9SensorApp9ErrorCell")
@interface ErrorCell : UITableViewCell
+ (NSString * _Nonnull)cellIdentifier;
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified errorLabel;
- (void)setDateOfLastError:(NSDate * _Nullable)date;
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end



/// The purpose of the GyroSensor class is to provide the data that is generated by the gyro of the device. For details of this sensor see https://en.wikipedia.org/wiki/Gyroscope
///
/// The <code>GyroSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp10GyroSensor")
@interface GyroSensor : AbstractSensor

/// A Bool that indicates that the gyro is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with the interval specified by gyroUpdateInterval
- (void)startReporting;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end



/// The purpose of the LightSensor class is to provide the data that is generated by the camera of the device. The LightSensor class is a subclass of the AbstractSensor, and it conforms to the DeviceSensor protocol.
SWIFT_CLASS("_TtC9SensorApp11LightSensor")
@interface LightSensor : AbstractSensor

/// A Bool that indicates that the camera on the back is available for video recording
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with a NSTimer that kicks of a reading in a defined interval
- (void)startReporting;

/// Method that gets called if the record timer fired. An image from the video stream is taken and the average brightness of all pixels is computed
- (void)intervalTimerFired;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end



/// The purpose of the MagnetometerSensor class is to provide the data that is generated by the magnetometer of the device. For details of this sensor see https://en.wikipedia.org/wiki/Magnetometer
///
/// The <code>MagnetometerSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp18MagnetometerSensor")
@interface MagnetometerSensor : AbstractSensor

/// A Bool that indicates that the magnetometer is available on the device
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with the interval specified by magnetometerUpdateInterval
- (void)startReporting;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end



/// The purpose of the MicrophoneSensor class is to provide the data that is generated by the microphone of the device.
///
/// The <code>MicrophoneSensor
/// </code> class is a subclass of the <code>AbstractSensor
/// </code>, and it conforms to the <code>DeviceSensor
/// </code> protocol.
SWIFT_CLASS("_TtC9SensorApp16MicrophoneSensor")
@interface MicrophoneSensor : AbstractSensor <AVAudioRecorderDelegate>

/// A Bool that indicates that the microphone is available on the device which is the case on real hardware
@property (nonatomic, readonly) BOOL isAvailable;

/// Method to start the reporting of sensor data. The data is read with a NSTimer that kicks of a reading in a defined interval
- (void)startReporting;

/// Method that gets called if the record timer fired. The normalized power values are recorded - nothing more
- (void)intervalTimerFired;

/// method that stops sensor reading and generation of data
- (void)stopReporting;
@end


SWIFT_CLASS("_TtC9SensorApp11SenderModel")
@interface SenderModel : NSObject
+ (SenderModel * _Nonnull)sharedInstance;

/// Method to initialize all senders
- (void)setup;

/// method to start all senders at once
- (void)startAllSenders;

/// method to stop all senders at once
- (void)shutdownSenders;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UISwitch;


/// This class is the view model for the sensor cell to enable the user to turn sensors on and off
SWIFT_CLASS("_TtC9SensorApp10SensorCell")
@interface SensorCell : UITableViewCell
+ (NSString * _Nonnull)cellIdentifier;
@property (nonatomic, weak) IBOutlet UISwitch * _Null_unspecified toggle;
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified label;
- (void)awakeFromNib;

/// Action listener when the toggle is tapped. Starts or stops the sensor.
- (IBAction)toggleSensor:(UISwitch * _Nonnull)sender;
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end



/// The purpose of the SensorModel class is to initialize all sensors and provide them to the application
SWIFT_CLASS("_TtC9SensorApp11SensorModel")
@interface SensorModel : NSObject
+ (SensorModel * _Nonnull)sharedInstance;

/// Method to Initialize all sensors
- (void)setup;

/// method to start all sensors at once
- (void)startAllSensors;

/// method to stop all sensors at once
- (void)shutdownSensors;
- (void)startTransfer;
@end

@class UITableView;
@class NSIndexPath;
@class SettingCell;
@class NSBundle;


/// This is the main view controller of the app which manages the settings view
SWIFT_CLASS("_TtC9SensorApp27SensorTogglesViewController")
@interface SensorTogglesViewController : UIViewController
@property (nonatomic, weak) IBOutlet UITableView * _Null_unspecified settingsTable;

/// Gets called when view is ready to be displayed
- (void)viewDidLoad;

/// Is been called by NSNotificationCenter
- (void)showTransmissionError:(NSNotification * _Nonnull)notification;

/// Gets a setting cell for the specified row
- (SettingCell * _Nonnull)resolveSettingsCell:(UITableView * _Nonnull)tableView indexPath:(NSIndexPath * _Nonnull)indexPath;

/// Gets a sensor (toggle) cell for the specified row
- (SensorCell * _Nonnull)resolveSensorCell:(UITableView * _Nonnull)tableView indexPath:(NSIndexPath * _Nonnull)indexPath;

/// Gets an error cell for the specified row
- (ErrorCell * _Nonnull)resolveErrorCell:(UITableView * _Nonnull)tableView indexPath:(NSIndexPath * _Nonnull)indexPath;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


@interface SensorTogglesViewController (SWIFT_EXTENSION(SensorApp)) <UITableViewDelegate, UIScrollViewDelegate>

/// Delegate that is called when a table cell in setting section is tapped. Displays a pop-up with a text input when tapped
- (void)tableView:(UITableView * _Nonnull)tableView didSelectRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;

/// Gets the name of the specified section
- (NSString * _Nullable)tableView:(UITableView * _Nonnull)tableView titleForHeaderInSection:(NSInteger)section;
@end


@interface SensorTogglesViewController (SWIFT_EXTENSION(SensorApp)) <UITableViewDataSource>

/// Table view consists 3 section
- (NSInteger)numberOfSectionsInTableView:(UITableView * _Nonnull)tableView;
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section;

/// Returns the right table cell according to the section
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
@end



/// This class is the view model for the setting cell. It shows the name of the setting item.
SWIFT_CLASS("_TtC9SensorApp11SettingCell")
@interface SettingCell : UITableViewCell
+ (NSString * _Nonnull)cellIdentifier;
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified label;
- (void)setDisplayName:(NSString * _Nonnull)displayName;
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end



/// This class initializes and keeps the setting objects.
SWIFT_CLASS("_TtC9SensorApp12SettingModel")
@interface SettingModel : NSObject
+ (SettingModel * _Nonnull)sharedInstance;
- (void)setup;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The purpose of the TransferService class is to transfer data from the cache to the backend. To parallize transfer of the sensor data there are multiple instances of the TransferService. One per DeviceSensor
SWIFT_CLASS("_TtC9SensorApp15TransferService")
@interface TransferService : NSObject

/// Tranfer data by requesting the oldest data by SensorType and delete the file after a successfull transmission. If the queue runs out of data the method calls itself with a delay
- (void)transfer;
@end


@interface UIDevice (SWIFT_EXTENSION(SensorApp))

/// Check if the app is Running on a simulator
@property (nonatomic, readonly) BOOL isSimulator;

/// Create and persist a DeviceID. This ID is used to identify the device and so the lift where it is installed. The deviceID is stored in NSUserDefaults and wiped if the app gets deleted.
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceID;
@end

#pragma clang diagnostic pop
